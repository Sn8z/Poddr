"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkFileInArchive = exports.AsarPackager = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

/** @internal */
let checkFileInArchive = exports.checkFileInArchive = (() => {
    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (asarFile, relativeFile, messagePrefix) {
        function error(text) {
            return new Error(`${messagePrefix} "${relativeFile}" in the "${asarFile}" ${text}`);
        }
        let fs;
        try {
            fs = yield (0, (_asar || _load_asar()).readAsar)(asarFile);
        } catch (e) {
            throw error(`is corrupted: ${e}`);
        }
        let stat;
        try {
            stat = fs.getFile(relativeFile);
        } catch (e) {
            const fileStat = yield (0, (_fs || _load_fs()).statOrNull)(asarFile);
            if (fileStat == null) {
                throw error(`does not exist. Seems like a wrong configuration.`);
            }
            // asar throws error on access to undefined object (info.link)
            stat = null;
        }
        if (stat == null) {
            throw error(`does not exist. Seems like a wrong configuration.`);
        }
        if (stat.size === 0) {
            throw error(`is corrupted: size 0`);
        }
    });

    return function checkFileInArchive(_x3, _x4, _x5) {
        return _ref2.apply(this, arguments);
    };
})();

let detectUnpackedDirs = (() => {
    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (fileSet, autoUnpackDirs, unpackedDest) {
        const dirToCreate = new Map();
        const metadata = fileSet.metadata;
        for (let i = 0, n = fileSet.files.length; i < n; i++) {
            const file = fileSet.files[i];
            const index = file.lastIndexOf((_AppFileCopierHelper || _load_AppFileCopierHelper()).NODE_MODULES_PATTERN);
            if (index < 0) {
                continue;
            }
            let nextSlashIndex = file.indexOf(_path.sep, index + (_AppFileCopierHelper || _load_AppFileCopierHelper()).NODE_MODULES_PATTERN.length + 1);
            if (nextSlashIndex < 0) {
                continue;
            }
            if (file[index + (_AppFileCopierHelper || _load_AppFileCopierHelper()).NODE_MODULES_PATTERN.length] === "@") {
                nextSlashIndex = file.indexOf(_path.sep, nextSlashIndex + 1);
            }
            if (!metadata.get(file).isFile()) {
                continue;
            }
            const packageDir = file.substring(0, nextSlashIndex);
            if (autoUnpackDirs.has(packageDir)) {
                const fileParent = _path.dirname(file);
                if (fileParent !== packageDir && !autoUnpackDirs.has(fileParent)) {
                    autoUnpackDirs.add(fileParent);
                    addValue(dirToCreate, getRelativePath(fileSet, packageDir), _path.relative(packageDir, fileParent));
                }
                continue;
            }
            let shouldUnpack = false;
            if (file.endsWith(".dll") || file.endsWith(".exe")) {
                shouldUnpack = true;
            } else if (!(file.indexOf(".", nextSlashIndex) !== -1) && _path.extname(file) === "") {
                shouldUnpack = yield isBinaryFile(file);
            }
            if (!shouldUnpack) {
                continue;
            }
            if ((_builderUtil || _load_builderUtil()).debug.enabled) {
                (0, (_builderUtil || _load_builderUtil()).debug)(`${getRelativePath(fileSet, packageDir)} is not packed into asar archive - contains executable code`);
            }
            let fileParent = _path.dirname(file);
            // create parent dir to be able to copy file later without directory existence check
            addValue(dirToCreate, getRelativePath(fileSet, packageDir), _path.relative(packageDir, fileParent));
            while (fileParent !== packageDir) {
                autoUnpackDirs.add(fileParent);
                fileParent = _path.dirname(fileParent);
            }
            autoUnpackDirs.add(packageDir);
        }
        if (dirToCreate.size > 0) {
            // child directories should be not created asynchronously - parent directories should be created first
            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(dirToCreate.keys(), (() => {
                var _ref4 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (it) {
                    const base = _path.join(unpackedDest, it);
                    yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(base);
                    yield (_bluebirdLst2 || _load_bluebirdLst2()).default.each(dirToCreate.get(it), function (it) {
                        return (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.join(base, it));
                    });
                });

                return function (_x9) {
                    return _ref4.apply(this, arguments);
                };
            })(), (_fs || _load_fs()).CONCURRENCY);
        }
    });

    return function detectUnpackedDirs(_x6, _x7, _x8) {
        return _ref3.apply(this, arguments);
    };
})();

let order = (() => {
    var _ref5 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (filenames, orderingFile, src) {
        const orderingFiles = (yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(orderingFile, "utf8")).split("\n").map(function (line) {
            if (line.indexOf(":") !== -1) {
                line = line.split(":").pop();
            }
            line = line.trim();
            if (line[0] === "/") {
                line = line.slice(1);
            }
            return line;
        });
        const ordering = [];
        for (const file of orderingFiles) {
            const pathComponents = file.split(_path.sep);
            for (const pathComponent of pathComponents) {
                ordering.push(_path.join(src, pathComponent));
            }
        }
        const sortedFiles = [];
        let missing = 0;
        const total = filenames.length;
        for (const file of ordering) {
            if (!(sortedFiles.indexOf(file) !== -1) && filenames.indexOf(file) !== -1) {
                sortedFiles.push(file);
            }
        }
        for (const file of filenames) {
            if (!(sortedFiles.indexOf(file) !== -1)) {
                sortedFiles.push(file);
                missing += 1;
            }
        }
        (0, (_builderUtil || _load_builderUtil()).log)(`Ordering file has ${(total - missing) / total * 100}% coverage.`);
        return sortedFiles;
    });

    return function order(_x10, _x11, _x12) {
        return _ref5.apply(this, arguments);
    };
})();

exports.copyFileOrData = copyFileOrData;

var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _fs;

function _load_fs() {
    return _fs = require("builder-util/out/fs");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _asar;

function _load_asar() {
    return _asar = require("../asar");
}

var _AppFileCopierHelper;

function _load_AppFileCopierHelper() {
    return _AppFileCopierHelper = require("./AppFileCopierHelper");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isBinaryFile = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify(require("isbinaryfile"));
const pickle = require("chromium-pickle-js");
function addValue(map, key, value) {
    let list = map.get(key);
    if (list == null) {
        list = [value];
        map.set(key, list);
    } else {
        list.push(value);
    }
}
function copyFileOrData(fileCopier, data, source, destination, stats) {
    if (data == null) {
        return fileCopier.copy(source, destination, stats);
    } else {
        return (0, (_fsExtraP || _load_fsExtraP()).writeFile)(destination, data);
    }
}
/** @internal */
class AsarPackager {
    constructor(src, destination, options, unpackPattern) {
        this.src = src;
        this.options = options;
        this.unpackPattern = unpackPattern;
        this.fs = new (_asar || _load_asar()).AsarFilesystem(this.src);
        this.outFile = _path.join(destination, "app.asar");
    }
    // sort files to minimize file change (i.e. asar file is not changed dramatically on small change)
    pack(fileSets, packager) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (_this.options.ordering != null) {
                // ordering doesn't support transformed files, but ordering is not used functionality - wait user report to fix it
                yield order(fileSets[0].files, _this.options.ordering, fileSets[0].src);
            }
            yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.dirname(_this.outFile));
            for (const fileSet of fileSets) {
                yield _this.createPackageFromFiles(fileSet, packager.info);
            }
            yield _this.writeAsarFile(fileSets);
        })();
    }
    createPackageFromFiles(fileSet, packager) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const metadata = fileSet.metadata;
            // search auto unpacked dir
            const unpackedDirs = new Set();
            const unpackedDest = `${_this2.outFile}.unpacked`;
            if (_this2.options.smartUnpack !== false) {
                yield detectUnpackedDirs(fileSet, unpackedDirs, unpackedDest);
            }
            const dirToCreateForUnpackedFiles = new Set(unpackedDirs);
            const isDirNodeUnpacked = (() => {
                var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file, dirNode) {
                    if (dirNode.unpacked) {
                        return;
                    }
                    if (unpackedDirs.has(file)) {
                        dirNode.unpacked = true;
                    } else {
                        for (const dir of unpackedDirs) {
                            if (file.length > dir.length + 2 && file[dir.length] === _path.sep && file.startsWith(dir)) {
                                dirNode.unpacked = true;
                                unpackedDirs.add(file);
                                // not all dirs marked as unpacked after first iteration - because node module dir can be marked as unpacked after processing node module dir content
                                // e.g. node-notifier/example/advanced.js processed, but only on process vendor/terminal-notifier.app module will be marked as unpacked
                                yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(getTargetPath(fileSet, file, unpackedDest));
                                break;
                            }
                        }
                    }
                });

                return function isDirNodeUnpacked(_x, _x2) {
                    return _ref.apply(this, arguments);
                };
            })();
            const transformedFiles = fileSet.transformedFiles;
            const taskManager = new (_builderUtil || _load_builderUtil()).AsyncTaskManager(packager.cancellationToken);
            const fileCopier = new (_fs || _load_fs()).FileCopier();
            let currentDirNode = null;
            let currentDirPath = null;
            for (let i = 0, n = fileSet.files.length; i < n; i++) {
                const file = fileSet.files[i];
                const stat = metadata.get(file);
                if (stat != null && stat.isFile()) {
                    const fileParent = _path.dirname(file);
                    if (currentDirPath !== fileParent) {
                        currentDirPath = fileParent;
                        currentDirNode = _this2.fs.getOrCreateNode(getRelativePath(fileSet, fileParent));
                        yield isDirNodeUnpacked(fileParent, currentDirNode);
                    }
                    const dirNode = currentDirNode;
                    const newData = transformedFiles == null ? null : transformedFiles[i];
                    const isUnpacked = dirNode.unpacked || _this2.unpackPattern != null && _this2.unpackPattern(file, stat);
                    _this2.fs.addFileNode(file, dirNode, newData == null ? stat.size : Buffer.byteLength(newData), isUnpacked, stat);
                    if (isUnpacked) {
                        if (newData != null) {
                            transformedFiles[i] = null;
                        }
                        if (!dirNode.unpacked && !dirToCreateForUnpackedFiles.has(fileParent)) {
                            dirToCreateForUnpackedFiles.add(fileParent);
                            yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(getTargetPath(fileSet, fileParent, unpackedDest));
                        }
                        const unpackedFile = getTargetPath(fileSet, file, unpackedDest);
                        taskManager.addTask(copyFileOrData(fileCopier, newData, file, unpackedFile, stat));
                        if (taskManager.tasks.length > (_fs || _load_fs()).MAX_FILE_REQUESTS) {
                            yield taskManager.awaitTasks();
                        }
                    } else if (newData == null) {
                        transformedFiles[i] = true;
                    }
                } else if (stat == null || stat.isDirectory()) {
                    let unpacked = false;
                    if (unpackedDirs.has(file)) {
                        unpacked = true;
                    } else {
                        for (const dir of unpackedDirs) {
                            if (file.length > dir.length + 2 && file[dir.length] === _path.sep && file.startsWith(dir)) {
                                unpacked = true;
                                unpackedDirs.add(file);
                                // not all dirs marked as unpacked after first iteration - because node module dir can be marked as unpacked after processing node module dir content
                                // e.g. node-notifier/example/advanced.js processed, but only on process vendor/terminal-notifier.app module will be marked as unpacked
                                yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(getTargetPath(fileSet, file, unpackedDest));
                                break;
                            }
                        }
                    }
                    _this2.fs.insertDirectory(getRelativePath(fileSet, file), unpacked);
                } else if (stat.isSymbolicLink()) {
                    _this2.fs.getOrCreateNode(getRelativePath(fileSet, file)).link = stat.relativeLink;
                }
            }
            if (taskManager.tasks.length > 0) {
                yield taskManager.awaitTasks();
            }
        })();
    }
    writeAsarFile(fileSets) {
        const headerPickle = pickle.createEmpty();
        headerPickle.writeString(JSON.stringify(this.fs.header));
        const headerBuf = headerPickle.toBuffer();
        const sizePickle = pickle.createEmpty();
        sizePickle.writeUInt32(headerBuf.length);
        const sizeBuf = sizePickle.toBuffer();
        const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(this.outFile);
        return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
            writeStream.on("error", reject);
            writeStream.on("close", resolve);
            writeStream.write(sizeBuf);
            let fileSetIndex = 0;
            let files = fileSets[0].files;
            let transformedFiles = fileSets[0].transformedFiles;
            const w = index => {
                let data;
                while (true) {
                    if (index >= files.length) {
                        if (++fileSetIndex >= fileSets.length) {
                            writeStream.end();
                            return;
                        } else {
                            files = fileSets[fileSetIndex].files;
                            transformedFiles = fileSets[fileSetIndex].transformedFiles;
                            index = 0;
                        }
                    }
                    if ((data = transformedFiles[index++]) != null) {
                        break;
                    }
                }
                const file = files[index - 1];
                if (data !== true) {
                    writeStream.write(data, () => w(index));
                    return;
                }
                const readStream = (0, (_fsExtraP || _load_fsExtraP()).createReadStream)(file);
                readStream.on("error", reject);
                readStream.once("end", () => w(index));
                readStream.pipe(writeStream, {
                    end: false
                });
            };
            writeStream.write(headerBuf, () => w(0));
        });
    }
}exports.AsarPackager = AsarPackager;

function getRelativePath(fileSet, p) {
    const relative = p.substring((0, (_AppFileCopierHelper || _load_AppFileCopierHelper()).ensureEndSlash)(fileSet.src).length);
    if (_path.sep === "\\") {
        if (relative.startsWith("\\")) {
            // windows problem: double backslash, the above substring call removes root path with a single slash, so here can me some leftovers
            return relative.substring(1);
        }
    }
    return relative;
}
function getTargetPath(fileSet, p, to) {
    if (p === fileSet.src) {
        return to;
    }
    return p.replace((0, (_AppFileCopierHelper || _load_AppFileCopierHelper()).ensureEndSlash)(fileSet.src), (0, (_AppFileCopierHelper || _load_AppFileCopierHelper()).ensureEndSlash)(to));
}
//# sourceMappingURL=asarUtil.js.map