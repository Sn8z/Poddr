"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getPublishConfigs = exports.getPublishConfigsForUpdateInfo = exports.PublishManager = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

let getPublishConfigsForUpdateInfo = exports.getPublishConfigsForUpdateInfo = (() => {
    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (packager, publishConfigs, arch) {
        if (publishConfigs === null) {
            return null;
        }
        if (publishConfigs.length === 0) {
            debug("getPublishConfigsForUpdateInfo: no publishConfigs, detect using repository info");
            // https://github.com/electron-userland/electron-builder/issues/925#issuecomment-261732378
            // default publish config is github, file should be generated regardless of publish state (user can test installer locally or manage the release process manually)
            const repositoryInfo = yield packager.info.repositoryInfo;
            debug(`getPublishConfigsForUpdateInfo: ${(0, (_builderUtil || _load_builderUtil()).safeStringifyJson)(repositoryInfo)}`);
            if (repositoryInfo != null && repositoryInfo.type === "github") {
                const resolvedPublishConfig = yield getResolvedPublishConfig(packager, { provider: repositoryInfo.type }, arch, false);
                if (resolvedPublishConfig != null) {
                    debug(`getPublishConfigsForUpdateInfo: resolve to publish config ${(0, (_builderUtil || _load_builderUtil()).safeStringifyJson)(resolvedPublishConfig)}`);
                    return [resolvedPublishConfig];
                }
            }
        }
        return publishConfigs;
    });

    return function getPublishConfigsForUpdateInfo(_x2, _x3, _x4) {
        return _ref2.apply(this, arguments);
    };
})();

let writeUpdateInfo = (() => {
    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (event, _publishConfigs) {
        const packager = event.packager;
        const publishConfigs = yield getPublishConfigsForUpdateInfo(packager, _publishConfigs, event.arch);
        if (publishConfigs == null || publishConfigs.length === 0) {
            return;
        }
        const target = event.target;
        let outDir = target.outDir;
        if (event.packager.platform === (_core || _load_core()).Platform.WINDOWS && target.name !== "nsis") {
            outDir = _path.join(outDir, target.name);
            yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(outDir);
        }
        const version = packager.appInfo.version;
        const sha2 = new (_lazyVal || _load_lazyVal()).Lazy(function () {
            return (0, (_asarIntegrity || _load_asarIntegrity()).hashFile)(event.file, "sha256", "hex");
        });
        const sha512 = new (_lazyVal || _load_lazyVal()).Lazy(function () {
            return (0, (_asarIntegrity || _load_asarIntegrity()).hashFile)(event.file, "sha512", "base64");
        });
        const isMac = packager.platform === (_core || _load_core()).Platform.MAC;
        const releaseInfo = Object.assign({}, packager.config.releaseInfo);
        if (releaseInfo.releaseNotes == null) {
            const releaseNotesFile = yield packager.getResource(releaseInfo.releaseNotesFile, "release-notes.md");
            const releaseNotes = releaseNotesFile == null ? null : yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(releaseNotesFile, "utf-8");
            // to avoid undefined in the file, check for null
            if (releaseNotes != null) {
                releaseInfo.releaseNotes = releaseNotes;
            }
        }
        delete releaseInfo.releaseNotesFile;
        const createdFiles = new Set();
        for (const publishConfig of publishConfigs) {
            if (publishConfig.provider === "bintray") {
                continue;
            }
            const channel = publishConfig.channel || "latest";
            let dir = outDir;
            if (publishConfigs.length > 1 && publishConfig !== publishConfigs[0]) {
                dir = _path.join(outDir, publishConfig.provider);
            }
            if (isMac) {
                const isGitHub = publishConfig.provider === "github";
                // backward compatibility - write json file
                const updateInfoFile = isGitHub && outDir === dir ? _path.join(dir, "github", `${channel}-mac.json`) : _path.join(dir, `${channel}-mac.json`);
                if (!createdFiles.has(updateInfoFile)) {
                    createdFiles.add(updateInfoFile);
                    yield (0, (_fsExtraP || _load_fsExtraP()).outputJson)(updateInfoFile, {
                        version,
                        releaseDate: new Date().toISOString(),
                        url: computeDownloadUrl(publishConfig, packager.generateName2("zip", "mac", isGitHub), packager)
                    }, { spaces: 2 });
                    packager.info.dispatchArtifactCreated({
                        file: updateInfoFile,
                        arch: null,
                        packager,
                        target: null,
                        publishConfig
                    });
                }
            }
            const updateInfoFile = _path.join(dir, `${channel}${isMac ? "-mac" : ""}.yml`);
            if (createdFiles.has(updateInfoFile)) {
                continue;
            }
            createdFiles.add(updateInfoFile);
            const info = Object.assign({ version, releaseDate: new Date().toISOString(), path: _path.basename(event.file), sha512: yield sha512.value }, releaseInfo);
            const packageFiles = event.packageFiles;
            if (packageFiles != null) {
                const keys = Object.keys(packageFiles);
                if (keys.length > 0) {
                    info.packages = {};
                    for (const arch of keys) {
                        info.packages[arch] = _path.basename(packageFiles[arch]);
                    }
                }
            }
            if (event.safeArtifactName != null) {
                info.githubArtifactName = event.safeArtifactName;
            }
            if (packager.platform === (_core || _load_core()).Platform.WINDOWS) {
                // backward compatibility
                info.sha2 = yield sha2.value;
            }
            yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(updateInfoFile, (0, (_jsYaml || _load_jsYaml()).safeDump)(info));
            // artifact should be uploaded only to designated publish provider
            packager.info.dispatchArtifactCreated({
                file: updateInfoFile,
                arch: null,
                packager,
                target: null,
                publishConfig
            });
        }
    });

    return function writeUpdateInfo(_x5, _x6) {
        return _ref3.apply(this, arguments);
    };
})();

let getPublishConfigs = exports.getPublishConfigs = (() => {
    var _ref4 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (packager, targetSpecificOptions, arch) {
        let publishers;
        // check build.nsis (target)
        if (targetSpecificOptions != null) {
            publishers = targetSpecificOptions.publish;
            // if explicitly set to null - do not publish
            if (publishers === null) {
                return null;
            }
        }
        // check build.win (platform)
        if (publishers == null) {
            publishers = packager.platformSpecificBuildOptions.publish;
            if (publishers === null) {
                return null;
            }
        }
        if (publishers == null) {
            publishers = packager.config.publish;
            if (publishers === null) {
                return null;
            }
        }
        if (publishers == null) {
            let serviceName = null;
            if (!(0, (_builderUtil || _load_builderUtil()).isEmptyOrSpaces)(process.env.GH_TOKEN)) {
                serviceName = "github";
            } else if (!(0, (_builderUtil || _load_builderUtil()).isEmptyOrSpaces)(process.env.BT_TOKEN)) {
                serviceName = "bintray";
            }
            if (serviceName != null) {
                debug(`Detect ${serviceName} as publish provider`);
                return [yield getResolvedPublishConfig(packager, { provider: serviceName }, arch)];
            }
        }
        if (publishers == null) {
            return [];
        }
        debug(`Explicit publish provider: ${(0, (_builderUtil || _load_builderUtil()).safeStringifyJson)(publishers)}`);
        return yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map((0, (_builderUtil || _load_builderUtil()).asArray)(publishers), function (it) {
            return getResolvedPublishConfig(packager, typeof it === "string" ? { provider: it } : it, arch);
        });
    });

    return function getPublishConfigs(_x7, _x8, _x9) {
        return _ref4.apply(this, arguments);
    };
})();

let getResolvedPublishConfig = (() => {
    var _ref5 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (packager, options, arch) {
        let getInfo = (() => {
            var _ref6 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
                const info = yield packager.info.repositoryInfo;
                if (info != null) {
                    return info;
                }
                const message = `Cannot detect repository by .git/config. Please specify "repository" in the package.json (https://docs.npmjs.com/files/package.json#repository).\nPlease see https://electron.build/publishing-artifacts`;
                if (errorIfCannot) {
                    throw new Error(message);
                } else {
                    (0, (_builderUtil || _load_builderUtil()).warn)(message);
                    return null;
                }
            });

            return function getInfo() {
                return _ref6.apply(this, arguments);
            };
        })();

        let errorIfCannot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

        options = Object.assign(Object.create(null), options);
        expandPublishConfig(options, packager, arch);
        let channelFromAppVersion = null;
        if (options.channel == null && packager.config.detectUpdateChannel !== false) {
            channelFromAppVersion = packager.appInfo.channel;
        }
        const provider = options.provider;
        if (provider === "generic") {
            const o = options;
            if (o.url == null) {
                throw new Error(`Please specify "url" for "generic" update server`);
            }
            if (channelFromAppVersion != null) {
                o.channel = channelFromAppVersion;
            }
            return options;
        }
        const providerClass = requireProviderClass(options.provider);
        if (providerClass != null && providerClass.checkAndResolveOptions != null) {
            yield providerClass.checkAndResolveOptions(options, channelFromAppVersion);
            return options;
        }
        const isGithub = provider === "github";
        if (!isGithub && provider !== "bintray") {
            return options;
        }
        let owner = isGithub ? options.owner : options.owner;
        let project = isGithub ? options.repo : options.package;
        if (isGithub && owner == null && project != null) {
            const index = project.indexOf("/");
            if (index > 0) {
                const repo = project;
                project = repo.substring(0, index);
                owner = repo.substring(index + 1);
            }
        }

        if (!owner || !project) {
            debug(`Owner or project is not specified explicitly for ${provider}, call getInfo: owner: ${owner}, project: ${project}`);
            const info = yield getInfo();
            if (info == null) {
                return null;
            }
            if (!owner) {
                owner = info.user;
            }
            if (!project) {
                project = info.project;
            }
        }
        if (isGithub) {
            if (options.token != null && !options.private) {
                (0, (_builderUtil || _load_builderUtil()).warn)('"token" specified in the github publish options. It should be used only for [setFeedURL](module:electron-updater/out/AppUpdater.AppUpdater+setFeedURL).');
            }
            return Object.assign({ owner, repo: project }, options);
        } else {
            return Object.assign({ owner, package: project }, options);
        }
    });

    return function getResolvedPublishConfig(_x10, _x11, _x12) {
        return _ref5.apply(this, arguments);
    };
})();
//# sourceMappingURL=PublishManager.js.map


exports.createPublisher = createPublisher;
exports.computeDownloadUrl = computeDownloadUrl;

var _asarIntegrity;

function _load_asarIntegrity() {
    return _asarIntegrity = require("asar-integrity");
}

var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _debug2 = _interopRequireDefault(require("debug"));

var _publishOptions;

function _load_publishOptions() {
    return _publishOptions = require("electron-builder-http/out/publishOptions");
}

var _electronPublish;

function _load_electronPublish() {
    return _electronPublish = require("electron-publish");
}

var _BintrayPublisher;

function _load_BintrayPublisher() {
    return _BintrayPublisher = require("electron-publish/out/BintrayPublisher");
}

var _gitHubPublisher;

function _load_gitHubPublisher() {
    return _gitHubPublisher = require("electron-publish/out/gitHubPublisher");
}

var _multiProgress;

function _load_multiProgress() {
    return _multiProgress = require("electron-publish/out/multiProgress");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _isCi;

function _load_isCi() {
    return _isCi = _interopRequireDefault(require("is-ci"));
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = require("js-yaml");
}

var _lazyVal;

function _load_lazyVal() {
    return _lazyVal = require("lazy-val");
}

var _path = _interopRequireWildcard(require("path"));

var _url;

function _load_url() {
    return _url = _interopRequireWildcard(require("url"));
}

var _core;

function _load_core() {
    return _core = require("../core");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const publishForPrWarning = "There are serious security concerns with PUBLISH_FOR_PULL_REQUEST=true (see the  CircleCI documentation (https://circleci.com/docs/1.0/fork-pr-builds/) for details)" + "\nIf you have SSH keys, sensitive env vars or AWS credentials stored in your project settings and untrusted forks can make pull requests against your repo, then this option isn't for you.";
const debug = (0, _debug2.default)("electron-builder:publish");
class PublishManager {
    constructor(packager, publishOptions, cancellationToken) {
        this.publishOptions = publishOptions;
        this.cancellationToken = cancellationToken;
        this.nameToPublisher = new Map();
        this.progress = process.stdout.isTTY ? new (_multiProgress || _load_multiProgress()).MultiProgress() : null;
        this.taskManager = new (_builderUtil || _load_builderUtil()).AsyncTaskManager(cancellationToken);
        const forcePublishForPr = process.env.PUBLISH_FOR_PULL_REQUEST === "true";
        if (!(0, (_builderUtil || _load_builderUtil()).isPullRequest)() || forcePublishForPr) {
            if (publishOptions.publish === undefined) {
                if (process.env.npm_lifecycle_event === "release") {
                    publishOptions.publish = "always";
                } else {
                    const tag = (0, (_electronPublish || _load_electronPublish()).getCiTag)();
                    if (tag != null) {
                        (0, (_builderUtil || _load_builderUtil()).log)(`Tag ${tag} is defined, so artifacts will be published`);
                        publishOptions.publish = "onTag";
                    } else if ((_isCi || _load_isCi()).default) {
                        (0, (_builderUtil || _load_builderUtil()).log)("CI detected, so artifacts will be published if draft release exists");
                        publishOptions.publish = "onTagOrDraft";
                    }
                }
            }
            const publishPolicy = publishOptions.publish;
            this.isPublish = publishPolicy != null && publishOptions.publish !== "never" && (publishPolicy !== "onTag" || (0, (_electronPublish || _load_electronPublish()).getCiTag)() != null);
            if (this.isPublish && forcePublishForPr) {
                (0, (_builderUtil || _load_builderUtil()).warn)(publishForPrWarning);
            }
        } else if (publishOptions.publish !== "never") {
            (0, (_builderUtil || _load_builderUtil()).log)("Current build is a part of pull request, publishing will be skipped" + "\nSet env PUBLISH_FOR_PULL_REQUEST to true to force code signing." + `\n${publishForPrWarning}`);
        }
        packager.addAfterPackHandler((() => {
            var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (event) {
                const packager = event.packager;
                if (event.electronPlatformName === "darwin") {
                    if (!event.targets.some(function (it) {
                        return it.name === "zip";
                    })) {
                        return;
                    }
                } else if (packager.platform === (_core || _load_core()).Platform.WINDOWS) {
                    if (!event.targets.some(function (it) {
                        return isSuitableWindowsTarget(it, null);
                    })) {
                        return;
                    }
                } else {
                    return;
                }
                const publishConfigs = yield getPublishConfigsForUpdateInfo(packager, (yield getPublishConfigs(packager, null, event.arch)), event.arch);
                if (publishConfigs == null || publishConfigs.length === 0) {
                    return;
                }
                let publishConfig = publishConfigs[0];
                if (packager.platform === (_core || _load_core()).Platform.WINDOWS && publishConfig.publisherName == null) {
                    const winPackager = packager;
                    if (winPackager.isForceCodeSigningVerification) {
                        const publisherName = yield winPackager.computedPublisherName.value;
                        if (publisherName != null) {
                            publishConfig = Object.assign({}, publishConfig, { publisherName });
                        }
                    }
                }
                yield (0, (_fsExtraP || _load_fsExtraP()).writeFile)(_path.join(packager.getResourcesDir(event.appOutDir), "app-update.yml"), (0, (_jsYaml || _load_jsYaml()).safeDump)(publishConfig));
            });

            return function (_x) {
                return _ref.apply(this, arguments);
            };
        })());
        packager.artifactCreated(event => this.taskManager.addTask(this.artifactCreated(event)));
    }
    artifactCreated(event) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = event.packager;
            const target = event.target;
            const publishConfigs = event.publishConfig == null ? yield getPublishConfigs(packager, target == null ? null : target.options, event.arch) : [event.publishConfig];
            if (debug.enabled) {
                debug(`artifactCreated: ${(0, (_builderUtil || _load_builderUtil()).safeStringifyJson)(event, new Set(["packager"]))},\npublishConfigs: ${(0, (_builderUtil || _load_builderUtil()).safeStringifyJson)(publishConfigs)},\nisPublish: ${_this.isPublish}`);
            }
            const eventFile = event.file;
            if (publishConfigs == null) {
                if (_this.isPublish) {
                    debug(`${eventFile} is not published: no publish configs`);
                }
                return;
            }
            if (_this.isPublish) {
                for (const publishConfig of publishConfigs) {
                    if (_this.cancellationToken.cancelled) {
                        debug(`${eventFile} is not published: cancelled`);
                        break;
                    }
                    const publisher = _this.getOrCreatePublisher(publishConfig, packager);
                    if (publisher == null) {
                        debug(`${eventFile} is not published: publisher is null, ${(0, (_builderUtil || _load_builderUtil()).safeStringifyJson)(publishConfig)}`);
                        continue;
                    }
                    if (eventFile == null) {
                        _this.taskManager.addTask(publisher.uploadData(event.data, event.arch || (_builderUtil || _load_builderUtil()).Arch.x64, event.safeArtifactName));
                    } else {
                        _this.taskManager.addTask(publisher.upload(eventFile, event.arch || (_builderUtil || _load_builderUtil()).Arch.x64, event.safeArtifactName));
                    }
                }
            }
            if (target != null && eventFile != null && !_this.cancellationToken.cancelled) {
                if (packager.platform === (_core || _load_core()).Platform.MAC && target.name === "zip" || packager.platform === (_core || _load_core()).Platform.WINDOWS && isSuitableWindowsTarget(target, event)) {
                    _this.taskManager.addTask(writeUpdateInfo(event, publishConfigs));
                }
            }
        })();
    }
    getOrCreatePublisher(publishConfig, platformPackager) {
        // to not include token into cache key
        const providerCacheKey = (0, (_builderUtil || _load_builderUtil()).safeStringifyJson)(publishConfig);
        let publisher = this.nameToPublisher.get(providerCacheKey);
        if (publisher == null) {
            publisher = createPublisher(this, platformPackager.info.metadata.version, publishConfig, this.publishOptions);
            this.nameToPublisher.set(providerCacheKey, publisher);
            (0, (_builderUtil || _load_builderUtil()).log)(`Publishing to ${publisher}`);
        }
        return publisher;
    }
    cancelTasks() {
        this.taskManager.cancelTasks();
        this.nameToPublisher.clear();
    }
    awaitTasks() {
        return this.taskManager.awaitTasks();
    }
}
exports.PublishManager = PublishManager;
function createPublisher(context, version, publishConfig, options) {
    if (debug.enabled) {
        debug(`create publisher: ${(0, (_builderUtil || _load_builderUtil()).safeStringifyJson)(publishConfig)}`);
    }
    const provider = publishConfig.provider;
    switch (provider) {
        case "github":
            return new (_gitHubPublisher || _load_gitHubPublisher()).GitHubPublisher(context, publishConfig, version, options);
        case "bintray":
            return new (_BintrayPublisher || _load_BintrayPublisher()).BintrayPublisher(context, publishConfig, version, options);
        case "generic":
            return null;
        default:
            const clazz = requireProviderClass(provider);
            return clazz == null ? null : new clazz(context, publishConfig);
    }
}
function requireProviderClass(provider) {
    switch (provider) {
        case "github":
            return (_gitHubPublisher || _load_gitHubPublisher()).GitHubPublisher;
        case "bintray":
            return (_BintrayPublisher || _load_BintrayPublisher()).BintrayPublisher;
        case "generic":
            return null;
        default:
            return require(`electron-publisher-${provider}`).default;
    }
}
function computeDownloadUrl(publishConfig, fileName, packager) {
    if (publishConfig.provider === "generic") {
        const baseUrlString = publishConfig.url;
        if (fileName == null) {
            return baseUrlString;
        }
        const baseUrl = (_url || _load_url()).parse(baseUrlString);
        return (_url || _load_url()).format(Object.assign({}, baseUrl, { pathname: _path.posix.resolve(baseUrl.pathname || "/", encodeURI(fileName)) }));
    }
    let baseUrl;
    if (publishConfig.provider === "s3") {
        baseUrl = (0, (_publishOptions || _load_publishOptions()).s3Url)(publishConfig);
    } else {
        const gh = publishConfig;
        baseUrl = `${(0, (_publishOptions || _load_publishOptions()).githubUrl)(gh)}/${gh.owner}/${gh.repo}/releases/download/${gh.vPrefixedTagName === false ? "" : "v"}${packager.appInfo.version}`;
    }
    if (fileName == null) {
        return baseUrl;
    }
    return `${baseUrl}/${encodeURI(fileName)}`;
}

function isSuitableWindowsTarget(target, event) {
    if (event != null && !event.isWriteUpdateInfo) {
        return false;
    }
    if (target.name === "appx" && target.options != null && target.options.electronUpdaterAware) {
        return true;
    }
    return target.name === "nsis" || target.name.startsWith("nsis-");
}
function expandPublishConfig(options, packager, arch) {
    for (const name of Object.keys(options)) {
        const value = options[name];
        if (typeof value === "string") {
            const expanded = packager.expandMacro(value, arch == null ? null : (_builderUtil || _load_builderUtil()).Arch[arch]);
            if (expanded !== value) {
                options[name] = expanded;
            }
        }
    }
}