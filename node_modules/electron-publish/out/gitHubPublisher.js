"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GitHubPublisher = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = require("builder-util-runtime");
}

var _nodeHttpExecutor;

function _load_nodeHttpExecutor() {
    return _nodeHttpExecutor = require("builder-util/out/nodeHttpExecutor");
}

var _mime;

function _load_mime() {
    return _mime = _interopRequireDefault(require("mime"));
}

var _url;

function _load_url() {
    return _url = require("url");
}

var _publisher;

function _load_publisher() {
    return _publisher = require("./publisher");
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GitHubPublisher extends (_publisher || _load_publisher()).HttpPublisher {
    constructor(context, info, version, options = {}) {
        super(context, true);
        this.info = info;
        this.version = version;
        this.options = options;
        this._releasePromise = null;
        this.providerName = "GitHub";
        this.releaseLogFields = null;
        let token = info.token;
        if ((0, (_builderUtil || _load_builderUtil()).isEmptyOrSpaces)(token)) {
            token = process.env.GH_TOKEN || process.env.GITHUB_TOKEN;
            if ((0, (_builderUtil || _load_builderUtil()).isEmptyOrSpaces)(token)) {
                throw new (_builderUtil || _load_builderUtil()).InvalidConfigurationError(`GitHub Personal Access Token is not set, neither programmatically, nor using env "GH_TOKEN"`);
            }
            token = token.trim();
            if (!(0, (_builderUtil || _load_builderUtil()).isTokenCharValid)(token)) {
                throw new (_builderUtil || _load_builderUtil()).InvalidConfigurationError(`GitHub Personal Access Token (${JSON.stringify(token)}) contains invalid characters, please check env "GH_TOKEN"`);
            }
        }
        this.token = token;
        if (version.startsWith("v")) {
            throw new (_builderUtil || _load_builderUtil()).InvalidConfigurationError(`Version must not starts with "v": ${version}`);
        }
        this.tag = info.vPrefixedTagName === false ? version : `v${version}`;
        if ((0, (_builderUtil || _load_builderUtil()).isEnvTrue)(process.env.EP_DRAFT)) {
            this.releaseType = "draft";
            (_builderUtil || _load_builderUtil()).log.info({ reason: "env EP_DRAFT is set to true" }, "GitHub provider release type is set to draft");
        } else if ((0, (_builderUtil || _load_builderUtil()).isEnvTrue)(process.env.EP_PRELEASE)) {
            this.releaseType = "prerelease";
            (_builderUtil || _load_builderUtil()).log.info({ reason: "env EP_PRELEASE is set to true" }, "GitHub provider release type is set to prerelease");
        } else if (info.releaseType != null) {
            this.releaseType = info.releaseType;
        } else if (options.prerelease) {
            this.releaseType = "prerelease";
        } else {
            this.releaseType = options.draft === false ? "release" : "draft";
        }
    }
    /** @private */
    get releasePromise() {
        if (this._releasePromise == null) {
            this._releasePromise = this.token === "__test__" ? (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null) : this.getOrCreateRelease();
        }
        return this._releasePromise;
    }
    getOrCreateRelease() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const logFields = {
                tag: _this.tag,
                version: _this.version
            };
            // we don't use "Get a release by tag name" because "tag name" means existing git tag, but we draft release and don't create git tag
            const releases = yield _this.githubRequest(`/repos/${_this.info.owner}/${_this.info.repo}/releases`, _this.token);
            for (const release of releases) {
                if (!(release.tag_name === _this.tag || release.tag_name === _this.version)) {
                    continue;
                }
                if (release.draft) {
                    return release;
                }
                // https://github.com/electron-userland/electron-builder/issues/1197
                // https://electron-builder.slack.com/archives/general/p1485961449000202
                // https://github.com/electron-userland/electron-builder/issues/2072
                if (_this.releaseType === "draft") {
                    _this.releaseLogFields = Object.assign({ reason: "existing type not compatible with publishing type" }, logFields, { existingType: release.prerelease ? "pre-release" : "release", publishingType: _this.releaseType });
                    (_builderUtil || _load_builderUtil()).log.warn(_this.releaseLogFields, "GitHub release not created");
                    return null;
                }
                // https://github.com/electron-userland/electron-builder/issues/1133
                // https://github.com/electron-userland/electron-builder/issues/2074
                // if release created < 2 hours â€” allow to upload
                const publishedAt = release.published_at == null ? null : Date.parse(release.published_at);
                if (publishedAt != null && Date.now() - publishedAt > 2 * 3600 * 1000) {
                    // https://github.com/electron-userland/electron-builder/issues/1183#issuecomment-275867187
                    _this.releaseLogFields = Object.assign({ reason: "existing release published more than 2 hours ago" }, logFields, { date: new Date(publishedAt).toString() });
                    (_builderUtil || _load_builderUtil()).log.warn(_this.releaseLogFields, "GitHub release not created");
                    return null;
                }
                return release;
            }
            // https://github.com/electron-userland/electron-builder/issues/1835
            if (_this.options.publish === "always" || (0, (_publisher || _load_publisher()).getCiTag)() != null) {
                (_builderUtil || _load_builderUtil()).log.info(Object.assign({ reason: "release doesn't exist" }, logFields), `creating GitHub release`);
                return _this.createRelease();
            }
            _this.releaseLogFields = Object.assign({ reason: "release doesn't exist and not created because \"publish\" is not \"always\" and build is not on tag" }, logFields);
            return null;
        })();
    }
    doUpload(fileName, arch, dataLength, requestProcessor) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const release = yield _this2.releasePromise;
            if (release == null) {
                (_builderUtil || _load_builderUtil()).log.warn(Object.assign({ file: fileName }, _this2.releaseLogFields), "skipped publishing");
                return;
            }
            const parsedUrl = (0, (_url || _load_url()).parse)(release.upload_url.substring(0, release.upload_url.indexOf("{")) + "?name=" + fileName);
            let attemptNumber = 0;
            uploadAttempt: for (let i = 0; i < 3; i++) {
                try {
                    return yield (_nodeHttpExecutor || _load_nodeHttpExecutor()).httpExecutor.doApiRequest((0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptions)({
                        hostname: parsedUrl.hostname,
                        path: parsedUrl.path,
                        method: "POST",
                        headers: {
                            Accept: "application/vnd.github.v3+json",
                            "Content-Type": (_mime || _load_mime()).default.getType(fileName) || "application/octet-stream",
                            "Content-Length": dataLength
                        }
                    }, _this2.token), _this2.context.cancellationToken, requestProcessor);
                } catch (e) {
                    if (e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).HttpError) {
                        if (e.statusCode === 422 && e.description != null && e.description.errors != null && e.description.errors[0].code === "already_exists") {
                            // delete old artifact and re-upload
                            (_builderUtil || _load_builderUtil()).log.notice({ file: fileName, reason: "already exists on GitHub" }, "overwrite published file");
                            const assets = yield _this2.githubRequest(`/repos/${_this2.info.owner}/${_this2.info.repo}/releases/${release.id}/assets`, _this2.token, null);
                            for (const asset of assets) {
                                if (asset.name === fileName) {
                                    yield _this2.githubRequest(`/repos/${_this2.info.owner}/${_this2.info.repo}/releases/assets/${asset.id}`, _this2.token, null, "DELETE");
                                    continue uploadAttempt;
                                }
                            }
                            (_builderUtil || _load_builderUtil()).log.debug({ file: fileName, reason: "not found on GitHub" }, "trying to upload again");
                            continue;
                        } else if (attemptNumber++ < 3 && e.statusCode === 502) {
                            continue;
                        }
                    } else if (attemptNumber++ < 3 && (e.code === "EPIPE" || e.code === "ECONNRESET")) {
                        continue;
                    }
                    throw e;
                }
            }
        })();
    }
    createRelease() {
        return this.githubRequest(`/repos/${this.info.owner}/${this.info.repo}/releases`, this.token, {
            tag_name: this.tag,
            name: this.version,
            draft: this.releaseType === "draft",
            prerelease: this.releaseType === "prerelease"
        });
    }
    // test only
    //noinspection JSUnusedGlobalSymbols
    getRelease() {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            return _this3.githubRequest(`/repos/${_this3.info.owner}/${_this3.info.repo}/releases/${(yield _this3._releasePromise).id}`, _this3.token);
        })();
    }
    //noinspection JSUnusedGlobalSymbols
    deleteRelease() {
        var _this4 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const release = yield _this4._releasePromise;
            if (release == null) {
                return;
            }
            for (let i = 0; i < 3; i++) {
                try {
                    return yield _this4.githubRequest(`/repos/${_this4.info.owner}/${_this4.info.repo}/releases/${release.id}`, _this4.token, null, "DELETE");
                } catch (e) {
                    if (e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).HttpError) {
                        if (e.statusCode === 404) {
                            (_builderUtil || _load_builderUtil()).log.warn({ releaseId: release.id, reason: "doesn't exist" }, "cannot delete release");
                            return;
                        } else if (e.statusCode === 405 || e.statusCode === 502) {
                            continue;
                        }
                    }
                    throw e;
                }
            }
            (_builderUtil || _load_builderUtil()).log.warn({ releaseId: release.id }, "cannot delete release");
        })();
    }
    githubRequest(path, token, data = null, method) {
        // host can contains port, but node http doesn't support host as url does
        const baseUrl = (0, (_url || _load_url()).parse)(`https://${this.info.host || "api.github.com"}`);
        return (0, (_builderUtilRuntime || _load_builderUtilRuntime()).parseJson)((_nodeHttpExecutor || _load_nodeHttpExecutor()).httpExecutor.request((0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptions)({
            hostname: baseUrl.hostname,
            port: baseUrl.port,
            path: this.info.host != null && this.info.host !== "github.com" ? `/api/v3${path.startsWith("/") ? path : `/${path}`}` : path,
            headers: { Accept: "application/vnd.github.v3+json" }
        }, token, method), this.context.cancellationToken, data));
    }
    toString() {
        return `Github (owner: ${this.info.owner}, project: ${this.info.repo}, version: ${this.version})`;
    }
}
exports.GitHubPublisher = GitHubPublisher; //# sourceMappingURL=gitHubPublisher.js.map